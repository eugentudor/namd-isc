






/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */



/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure : public SDAG::Closure {
            int x;
            bool sameDevice;
            CProxy_DpcppPmePencilZ proxy;


      getDeviceBufferZ_4_closure() {
        init();
      }
      getDeviceBufferZ_4_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return x;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilZ & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | x;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBufferZ_4_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBufferZ_4_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure : public SDAG::Closure {
            int x;
            bool sameDevice;
            CProxy_DpcppPmePencilZ proxy;


      getDeviceBuffer_5_closure() {
        init();
      }
      getDeviceBuffer_5_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return x;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilZ & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | x;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer_5_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer_5_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure : public SDAG::Closure {
            CkCallback cb;


      recvDeviceBuffers_7_closure() {
        init();
      }
      recvDeviceBuffers_7_closure(CkMigrateMessage*) {
        init();
      }
            CkCallback & getP0() { return cb;}
      void pup(PUP::er& __p) {
        __p | cb;
        packClosure(__p);
      }
      virtual ~recvDeviceBuffers_7_closure() {
      }
      PUPable_decl(SINGLE_ARG(recvDeviceBuffers_7_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */



/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure : public SDAG::Closure {
            int x;
            bool sameDevice;
            CProxy_DpcppPmePencilY proxy;


      getDeviceBuffer2_4_closure() {
        init();
      }
      getDeviceBuffer2_4_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return x;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilY & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | x;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer2_4_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer2_4_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilX::getDeviceBuffer_5_closure : public SDAG::Closure {
            int x;
            bool sameDevice;
            CProxy_DpcppPmePencilY proxy;


      getDeviceBuffer_5_closure() {
        init();
      }
      getDeviceBuffer_5_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return x;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilY & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | x;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer_5_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer_5_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure : public SDAG::Closure {
            CkCallback cb;


      recvDeviceBuffers_7_closure() {
        init();
      }
      recvDeviceBuffers_7_closure(CkMigrateMessage*) {
        init();
      }
            CkCallback & getP0() { return cb;}
      void pup(PUP::er& __p) {
        __p | cb;
        packClosure(__p);
      }
      virtual ~recvDeviceBuffers_7_closure() {
      }
      PUPable_decl(SINGLE_ARG(recvDeviceBuffers_7_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure : public SDAG::Closure {
            int y;
            bool sameDevice;
            CProxy_DpcppPmePencilX proxy;


      getDeviceBuffer2_4_closure() {
        init();
      }
      getDeviceBuffer2_4_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return y;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilX & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | y;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer2_4_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer2_4_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilY::getDeviceBuffer_5_closure : public SDAG::Closure {
            int y;
            bool sameDevice;
            CProxy_DpcppPmePencilX proxy;


      getDeviceBuffer_5_closure() {
        init();
      }
      getDeviceBuffer_5_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return y;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilX & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | y;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer_5_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer_5_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure : public SDAG::Closure {
            int y;
            bool sameDevice;
            CProxy_DpcppPmePencilZ proxy;


      getDeviceBuffer22_6_closure() {
        init();
      }
      getDeviceBuffer22_6_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return y;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilZ & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | y;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer22_6_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer22_6_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilY::getDeviceBuffer_7_closure : public SDAG::Closure {
            int y;
            bool sameDevice;
            CProxy_DpcppPmePencilZ proxy;


      getDeviceBuffer_7_closure() {
        init();
      }
      getDeviceBuffer_7_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return y;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilZ & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | y;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer_7_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer_7_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure : public SDAG::Closure {
            CkCallback cb;


      recvDeviceBuffers_10_closure() {
        init();
      }
      recvDeviceBuffers_10_closure(CkMigrateMessage*) {
        init();
      }
            CkCallback & getP0() { return cb;}
      void pup(PUP::er& __p) {
        __p | cb;
        packClosure(__p);
      }
      virtual ~recvDeviceBuffers_10_closure() {
      }
      PUPable_decl(SINGLE_ARG(recvDeviceBuffers_10_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure : public SDAG::Closure {
            int z;
            bool sameDevice;
            CProxy_DpcppPmePencilXY proxy;


      getDeviceBufferXY_5_closure() {
        init();
      }
      getDeviceBufferXY_5_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return z;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilXY & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | z;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBufferXY_5_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBufferXY_5_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure : public SDAG::Closure {
            int z;
            bool sameDevice;
            CProxy_DpcppPmePencilXY proxy;


      getDeviceBuffer_6_closure() {
        init();
      }
      getDeviceBuffer_6_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return z;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilXY & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | z;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer_6_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer_6_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure : public SDAG::Closure {
            int z;
            bool sameDevice;
            CProxy_DpcppPmePencilY proxy;


      getDeviceBufferY_7_closure() {
        init();
      }
      getDeviceBufferY_7_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return z;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilY & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | z;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBufferY_7_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBufferY_7_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure : public SDAG::Closure {
            int z;
            bool sameDevice;
            CProxy_DpcppPmePencilY proxy;


      getDeviceBuffer_8_closure() {
        init();
      }
      getDeviceBuffer_8_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return z;}
            bool & getP1() { return sameDevice;}
            CProxy_DpcppPmePencilY & getP2() { return proxy;}
      void pup(PUP::er& __p) {
        __p | z;
        __p | sameDevice;
        __p | proxy;
        packClosure(__p);
      }
      virtual ~getDeviceBuffer_8_closure() {
      }
      PUPable_decl(SINGLE_ARG(getDeviceBuffer_8_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure : public SDAG::Closure {
            CkCallback cb;


      recvDeviceBuffers_10_closure() {
        init();
      }
      recvDeviceBuffers_10_closure(CkMigrateMessage*) {
        init();
      }
            CkCallback & getP0() { return cb;}
      void pup(PUP::er& __p) {
        __p | cb;
        packClosure(__p);
      }
      virtual ~recvDeviceBuffers_10_closure() {
      }
      PUPable_decl(SINGLE_ARG(recvDeviceBuffers_10_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: message DpcppPmeXYZInitMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_DpcppPmeXYZInitMsg::operator new(size_t s){
  return DpcppPmeXYZInitMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_DpcppPmeXYZInitMsg::operator new(size_t s, int* sz){
  return DpcppPmeXYZInitMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_DpcppPmeXYZInitMsg::operator new(size_t s, int* sz,const int pb){
  return DpcppPmeXYZInitMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_DpcppPmeXYZInitMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return DpcppPmeXYZInitMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_DpcppPmeXYZInitMsg::operator new(size_t s, const int p) {
  return DpcppPmeXYZInitMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_DpcppPmeXYZInitMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return DpcppPmeXYZInitMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_DpcppPmeXYZInitMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_DpcppPmeXYZInitMsg::CMessage_DpcppPmeXYZInitMsg() {
DpcppPmeXYZInitMsg *newmsg = (DpcppPmeXYZInitMsg *)this;
}
void CMessage_DpcppPmeXYZInitMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_DpcppPmeXYZInitMsg::pack(DpcppPmeXYZInitMsg *msg) {
  return (void *) msg;
}
DpcppPmeXYZInitMsg* CMessage_DpcppPmeXYZInitMsg::unpack(void* buf) {
  DpcppPmeXYZInitMsg *msg = (DpcppPmeXYZInitMsg *) buf;
  return msg;
}
int CMessage_DpcppPmeXYZInitMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message DpcppPmeXYInitMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_DpcppPmeXYInitMsg::operator new(size_t s){
  return DpcppPmeXYInitMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_DpcppPmeXYInitMsg::operator new(size_t s, int* sz){
  return DpcppPmeXYInitMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_DpcppPmeXYInitMsg::operator new(size_t s, int* sz,const int pb){
  return DpcppPmeXYInitMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_DpcppPmeXYInitMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return DpcppPmeXYInitMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_DpcppPmeXYInitMsg::operator new(size_t s, const int p) {
  return DpcppPmeXYInitMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_DpcppPmeXYInitMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return DpcppPmeXYInitMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_DpcppPmeXYInitMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_DpcppPmeXYInitMsg::CMessage_DpcppPmeXYInitMsg() {
DpcppPmeXYInitMsg *newmsg = (DpcppPmeXYInitMsg *)this;
}
void CMessage_DpcppPmeXYInitMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_DpcppPmeXYInitMsg::pack(DpcppPmeXYInitMsg *msg) {
  return (void *) msg;
}
DpcppPmeXYInitMsg* CMessage_DpcppPmeXYInitMsg::unpack(void* buf) {
  DpcppPmeXYInitMsg *msg = (DpcppPmeXYInitMsg *) buf;
  return msg;
}
int CMessage_DpcppPmeXYInitMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message DpcppPmeXInitMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_DpcppPmeXInitMsg::operator new(size_t s){
  return DpcppPmeXInitMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_DpcppPmeXInitMsg::operator new(size_t s, int* sz){
  return DpcppPmeXInitMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_DpcppPmeXInitMsg::operator new(size_t s, int* sz,const int pb){
  return DpcppPmeXInitMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_DpcppPmeXInitMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return DpcppPmeXInitMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_DpcppPmeXInitMsg::operator new(size_t s, const int p) {
  return DpcppPmeXInitMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_DpcppPmeXInitMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return DpcppPmeXInitMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_DpcppPmeXInitMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_DpcppPmeXInitMsg::CMessage_DpcppPmeXInitMsg() {
DpcppPmeXInitMsg *newmsg = (DpcppPmeXInitMsg *)this;
}
void CMessage_DpcppPmeXInitMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_DpcppPmeXInitMsg::pack(DpcppPmeXInitMsg *msg) {
  return (void *) msg;
}
DpcppPmeXInitMsg* CMessage_DpcppPmeXInitMsg::unpack(void* buf) {
  DpcppPmeXInitMsg *msg = (DpcppPmeXInitMsg *) buf;
  return msg;
}
int CMessage_DpcppPmeXInitMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message InitDeviceMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_InitDeviceMsg::operator new(size_t s){
  return InitDeviceMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_InitDeviceMsg::operator new(size_t s, int* sz){
  return InitDeviceMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_InitDeviceMsg::operator new(size_t s, int* sz,const int pb){
  return InitDeviceMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_InitDeviceMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return InitDeviceMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_InitDeviceMsg::operator new(size_t s, const int p) {
  return InitDeviceMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_InitDeviceMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return InitDeviceMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_InitDeviceMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_InitDeviceMsg::CMessage_InitDeviceMsg() {
InitDeviceMsg *newmsg = (InitDeviceMsg *)this;
}
void CMessage_InitDeviceMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_InitDeviceMsg::pack(InitDeviceMsg *msg) {
  return (void *) msg;
}
InitDeviceMsg* CMessage_InitDeviceMsg::unpack(void* buf) {
  InitDeviceMsg *msg = (InitDeviceMsg *) buf;
  return msg;
}
int CMessage_InitDeviceMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message InitDeviceMsg2;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_InitDeviceMsg2::operator new(size_t s){
  return InitDeviceMsg2::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_InitDeviceMsg2::operator new(size_t s, int* sz){
  return InitDeviceMsg2::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_InitDeviceMsg2::operator new(size_t s, int* sz,const int pb){
  return InitDeviceMsg2::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_InitDeviceMsg2::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return InitDeviceMsg2::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_InitDeviceMsg2::operator new(size_t s, const int p) {
  return InitDeviceMsg2::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_InitDeviceMsg2::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return InitDeviceMsg2::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_InitDeviceMsg2::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_InitDeviceMsg2::CMessage_InitDeviceMsg2() {
InitDeviceMsg2 *newmsg = (InitDeviceMsg2 *)this;
}
void CMessage_InitDeviceMsg2::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_InitDeviceMsg2::pack(InitDeviceMsg2 *msg) {
  return (void *) msg;
}
InitDeviceMsg2* CMessage_InitDeviceMsg2::unpack(void* buf) {
  InitDeviceMsg2 *msg = (InitDeviceMsg2 *) buf;
  return msg;
}
int CMessage_InitDeviceMsg2::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message DeviceDataMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_DeviceDataMsg::operator new(size_t s){
  return DeviceDataMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_DeviceDataMsg::operator new(size_t s, int* sz){
  return DeviceDataMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_DeviceDataMsg::operator new(size_t s, int* sz,const int pb){
  return DeviceDataMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_DeviceDataMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return DeviceDataMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_DeviceDataMsg::operator new(size_t s, const int p) {
  return DeviceDataMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_DeviceDataMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return DeviceDataMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_DeviceDataMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_DeviceDataMsg::CMessage_DeviceDataMsg() {
DeviceDataMsg *newmsg = (DeviceDataMsg *)this;
}
void CMessage_DeviceDataMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_DeviceDataMsg::pack(DeviceDataMsg *msg) {
  return (void *) msg;
}
DeviceDataMsg* CMessage_DeviceDataMsg::unpack(void* buf) {
  DeviceDataMsg *msg = (DeviceDataMsg *) buf;
  return msg;
}
int CMessage_DeviceDataMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: array DpcppPmePencilXYZ: PmePencilXYZ{
DpcppPmePencilXYZ();
void initialize(DpcppPmeXYZInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg* impl_msg);
DpcppPmePencilXYZ(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_DpcppPmePencilXYZ::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_DpcppPmePencilXYZ::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilXYZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilXYZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilXYZ::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_DpcppPmePencilXYZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilXYZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXYZ();
 */
void CProxyElement_DpcppPmePencilXYZ::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_DpcppPmePencilXYZ::idx_DpcppPmePencilXYZ_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYZInitMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilXYZ::initialize(DpcppPmeXYZInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXYZ::idx_initialize_DpcppPmeXYZInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilXYZ::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXYZ::idx_initializeDevice_InitDeviceMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXYZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXYZ();
 */
CkArrayID CProxy_DpcppPmePencilXYZ::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilXYZ::idx_DpcppPmePencilXYZ_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilXYZ::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilXYZ::idx_DpcppPmePencilXYZ_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_DpcppPmePencilXYZ::ckNew(const int s1, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilXYZ::idx_DpcppPmePencilXYZ_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilXYZ::ckNew(const int s1, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilXYZ::idx_DpcppPmePencilXYZ_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXYZ::reg_DpcppPmePencilXYZ_void() {
  int epidx = CkRegisterEp("DpcppPmePencilXYZ()",
      _call_DpcppPmePencilXYZ_void, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilXYZ::_call_DpcppPmePencilXYZ_void(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXYZ* impl_obj = static_cast<DpcppPmePencilXYZ*>(impl_obj_void);
  new (impl_obj_void) DpcppPmePencilXYZ();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYZInitMsg* impl_msg);
 */
void CProxy_DpcppPmePencilXYZ::initialize(DpcppPmeXYZInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXYZ::idx_initialize_DpcppPmeXYZInitMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXYZ::reg_initialize_DpcppPmeXYZInitMsg() {
  int epidx = CkRegisterEp("initialize(DpcppPmeXYZInitMsg* impl_msg)",
      _call_initialize_DpcppPmeXYZInitMsg, CMessage_DpcppPmeXYZInitMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DpcppPmeXYZInitMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilXYZ::_call_initialize_DpcppPmeXYZInitMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXYZ* impl_obj = static_cast<DpcppPmePencilXYZ*>(impl_obj_void);
  impl_obj->initialize((DpcppPmeXYZInitMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxy_DpcppPmePencilXYZ::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXYZ::idx_initializeDevice_InitDeviceMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXYZ::reg_initializeDevice_InitDeviceMsg() {
  int epidx = CkRegisterEp("initializeDevice(InitDeviceMsg* impl_msg)",
      _call_initializeDevice_InitDeviceMsg, CMessage_InitDeviceMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)InitDeviceMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilXYZ::_call_initializeDevice_InitDeviceMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXYZ* impl_obj = static_cast<DpcppPmePencilXYZ*>(impl_obj_void);
  impl_obj->initializeDevice((InitDeviceMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXYZ(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_DpcppPmePencilXYZ::reg_DpcppPmePencilXYZ_CkMigrateMessage() {
  int epidx = CkRegisterEp("DpcppPmePencilXYZ(CkMigrateMessage* impl_msg)",
      _call_DpcppPmePencilXYZ_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilXYZ::_call_DpcppPmePencilXYZ_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<DpcppPmePencilXYZ> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXYZ();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYZInitMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilXYZ::initialize(DpcppPmeXYZInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXYZ::idx_initialize_DpcppPmeXYZInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilXYZ::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXYZ::idx_initializeDevice_InitDeviceMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXYZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_DpcppPmePencilXYZ::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 1);
  CkRegisterBase(__idx, CkIndex_PmePencilXYZ::__idx);
  // REG: DpcppPmePencilXYZ();
  idx_DpcppPmePencilXYZ_void();
  CkRegisterDefaultCtor(__idx, idx_DpcppPmePencilXYZ_void());

  // REG: void initialize(DpcppPmeXYZInitMsg* impl_msg);
  idx_initialize_DpcppPmeXYZInitMsg();

  // REG: void initializeDevice(InitDeviceMsg* impl_msg);
  idx_initializeDevice_InitDeviceMsg();

  // REG: DpcppPmePencilXYZ(CkMigrateMessage* impl_msg);
  idx_DpcppPmePencilXYZ_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_DpcppPmePencilXYZ_CkMigrateMessage());

}
#endif /* CK_TEMPLATES_ONLY */


/* DEFS: array DpcppPmePencilXY: PmePencilXY{
DpcppPmePencilXY();
void initialize(DpcppPmeXYInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg* impl_msg);
void getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void recvDeviceBuffer(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilXY(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_DpcppPmePencilXY::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_DpcppPmePencilXY::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilXY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilXY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilXY::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_DpcppPmePencilXY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilXY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXY();
 */
void CProxyElement_DpcppPmePencilXY::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_DpcppPmePencilXY::idx_DpcppPmePencilXY_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYInitMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilXY::initialize(DpcppPmeXYInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_initialize_DpcppPmeXYInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilXY::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_initializeDevice_InitDeviceMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxyElement_DpcppPmePencilXY::getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_getDeviceBufferZ_marshall4(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxyElement_DpcppPmePencilXY::getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_getDeviceBuffer_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilXY::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxyElement_DpcppPmePencilXY::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_recvDeviceBuffers_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXY();
 */
CkArrayID CProxy_DpcppPmePencilXY::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilXY::idx_DpcppPmePencilXY_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilXY::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilXY::idx_DpcppPmePencilXY_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_DpcppPmePencilXY::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilXY::idx_DpcppPmePencilXY_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilXY::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilXY::idx_DpcppPmePencilXY_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_DpcppPmePencilXY_void() {
  int epidx = CkRegisterEp("DpcppPmePencilXY()",
      _call_DpcppPmePencilXY_void, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_DpcppPmePencilXY_void(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  new (impl_obj_void) DpcppPmePencilXY();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYInitMsg* impl_msg);
 */
void CProxy_DpcppPmePencilXY::initialize(DpcppPmeXYInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXY::idx_initialize_DpcppPmeXYInitMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_initialize_DpcppPmeXYInitMsg() {
  int epidx = CkRegisterEp("initialize(DpcppPmeXYInitMsg* impl_msg)",
      _call_initialize_DpcppPmeXYInitMsg, CMessage_DpcppPmeXYInitMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DpcppPmeXYInitMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_initialize_DpcppPmeXYInitMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  impl_obj->initialize((DpcppPmeXYInitMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxy_DpcppPmePencilXY::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXY::idx_initializeDevice_InitDeviceMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_initializeDevice_InitDeviceMsg() {
  int epidx = CkRegisterEp("initializeDevice(InitDeviceMsg* impl_msg)",
      _call_initializeDevice_InitDeviceMsg, CMessage_InitDeviceMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)InitDeviceMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_initializeDevice_InitDeviceMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  impl_obj->initializeDevice((InitDeviceMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxy_DpcppPmePencilXY::getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXY::idx_getDeviceBufferZ_marshall4(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_getDeviceBufferZ_marshall4() {
  int epidx = CkRegisterEp("getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy)",
      _call_getDeviceBufferZ_marshall4, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBufferZ_marshall4);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBufferZ_marshall4);

  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_getDeviceBufferZ_marshall4(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure* genClosure = new Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBufferZ(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilXY::_callmarshall_getDeviceBufferZ_marshall4(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure* genClosure = new Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBufferZ(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilXY::_marshallmessagepup_getDeviceBufferZ_marshall4(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> x;
  implP|x;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilZ> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("x");
  implDestP|x;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxy_DpcppPmePencilXY::getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXY::idx_getDeviceBuffer_marshall5(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_getDeviceBuffer_marshall5() {
  int epidx = CkRegisterEp("getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy)",
      _call_getDeviceBuffer_marshall5, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer_marshall5);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer_marshall5);

  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_getDeviceBuffer_marshall5(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilXY::_callmarshall_getDeviceBuffer_marshall5(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilXY::_marshallmessagepup_getDeviceBuffer_marshall5(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> x;
  implP|x;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilZ> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("x");
  implDestP|x;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxy_DpcppPmePencilXY::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXY::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_recvDeviceBuffer_DeviceDataMsg() {
  int epidx = CkRegisterEp("recvDeviceBuffer(DeviceDataMsg* impl_msg)",
      _call_recvDeviceBuffer_DeviceDataMsg, CMessage_DeviceDataMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DeviceDataMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_recvDeviceBuffer_DeviceDataMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  impl_obj->recvDeviceBuffer((DeviceDataMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxy_DpcppPmePencilXY::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilXY::idx_recvDeviceBuffers_marshall7(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_recvDeviceBuffers_marshall7() {
  int epidx = CkRegisterEp("recvDeviceBuffers(const CkCallback &cb)",
      _call_recvDeviceBuffers_marshall7, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_recvDeviceBuffers_marshall7);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_recvDeviceBuffers_marshall7);

  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_recvDeviceBuffers_marshall7(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* genClosure = new Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilXY::_callmarshall_recvDeviceBuffers_marshall7(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilXY* impl_obj = static_cast<DpcppPmePencilXY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* genClosure = new Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilXY::_marshallmessagepup_recvDeviceBuffers_marshall7(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: const CkCallback &cb*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<CkCallback> cb;
  implP|cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("cb");
  implDestP|cb;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXY(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_DpcppPmePencilXY::reg_DpcppPmePencilXY_CkMigrateMessage() {
  int epidx = CkRegisterEp("DpcppPmePencilXY(CkMigrateMessage* impl_msg)",
      _call_DpcppPmePencilXY_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilXY::_call_DpcppPmePencilXY_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<DpcppPmePencilXY> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXY();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYInitMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilXY::initialize(DpcppPmeXYInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_initialize_DpcppPmeXYInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilXY::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_initializeDevice_InitDeviceMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxySection_DpcppPmePencilXY::getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_getDeviceBufferZ_marshall4(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxySection_DpcppPmePencilXY::getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_getDeviceBuffer_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilXY::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxySection_DpcppPmePencilXY::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilXY::idx_recvDeviceBuffers_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilXY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_DpcppPmePencilXY::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_PmePencilXY::__idx);
  // REG: DpcppPmePencilXY();
  idx_DpcppPmePencilXY_void();
  CkRegisterDefaultCtor(__idx, idx_DpcppPmePencilXY_void());

  // REG: void initialize(DpcppPmeXYInitMsg* impl_msg);
  idx_initialize_DpcppPmeXYInitMsg();

  // REG: void initializeDevice(InitDeviceMsg* impl_msg);
  idx_initializeDevice_InitDeviceMsg();

  // REG: void getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
  idx_getDeviceBufferZ_marshall4();

  // REG: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
  idx_getDeviceBuffer_marshall5();

  // REG: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
  idx_recvDeviceBuffer_DeviceDataMsg();

  // REG: void recvDeviceBuffers(const CkCallback &cb);
  idx_recvDeviceBuffers_marshall7();

  // REG: DpcppPmePencilXY(CkMigrateMessage* impl_msg);
  idx_DpcppPmePencilXY_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_DpcppPmePencilXY_CkMigrateMessage());

  DpcppPmePencilXY::__sdag_register(); // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::getDeviceBuffer(int x, bool sameDevice, CProxy_DpcppPmePencilZ proxy){
  Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure();
  genClosure->getP0() = x;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::getDeviceBuffer(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_0(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::getDeviceBuffer_end(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_0(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_0_end(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* gen0) {
  getDeviceBuffer_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_serial_0(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilXY_serial_0()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    int& x = gen0->getP0();
    bool& sameDevice = gen0->getP1();
    CProxy_DpcppPmePencilZ& proxy = gen0->getP2();
    { // begin serial block
#line 21 "inc/DpcppPmeSolver.ci"

    numGetDeviceBuffer++;
    getDeviceBufferZ(x, sameDevice, proxy);
   
#line 1917 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::recvDeviceBuffers(const CkCallback & cb){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "DpcppPmePencilXY", "recvDeviceBuffers(const CkCallback & cb)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_sdag_fnc_recvDeviceBuffers(const CkCallback & cb){
  Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* genClosure = new Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure();
  genClosure->getP0() = cb;
  _sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_sdag_fnc_recvDeviceBuffers(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_1(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::recvDeviceBuffers_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_1(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  _overlap_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_1_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  recvDeviceBuffers_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_overlap_0(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  _olist_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_overlap_0_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  _serial_3(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_olist_0(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  SDAG::CCounter *_co0= new SDAG::CCounter(2);
  _for_0(gen0, _co0);
  _for_1(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_olist_0_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _co0->decrement();
  if (_co0->isDone()) {
  _co0->deref();
    _overlap_0_end(gen0);
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_for_0(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg=0;
      if (imsg < numDeviceBuffers) {
        _slist_2(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_for_0_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      ++imsg;
      if (imsg < numDeviceBuffers) {
        _slist_2(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_2(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _when_0(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_2_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _for_0_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilXY::_when_0(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0, _co0, static_cast<DeviceDataMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_when_0_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        CmiFree(UsrToEnv(msg));
      }
    }
  }
  _slist_2_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_serial_1(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilXY_serial_1()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        { // begin serial block
#line 30 "inc/DpcppPmeSolver.ci"

      deviceBuffers[msg->i].data = msg->data;
      deviceBuffers[msg->i].event = msg->event;
      delete msg;
     
#line 2105 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_for_1(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgZ=0;
      if (imsgZ < numGetDeviceBuffer) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_for_1_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgZ++;
      if (imsgZ < numGetDeviceBuffer) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_3(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _when_1(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_slist_3_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _for_1_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilXY::_when_1(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, _co0, static_cast<Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure*>(buf0->cl));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_when_1_end(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure* gen2) {
  _slist_3_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_serial_2(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilXY_serial_2()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        int& x = gen2->getP0();
        bool& sameDevice = gen2->getP1();
        CProxy_DpcppPmePencilZ& proxy = gen2->getP2();
        { // begin serial block
#line 37 "inc/DpcppPmeSolver.ci"

      proxy(x,0,0).recvDeviceBuffer(new DeviceDataMsg(thisIndex.z, event, getData(x, sameDevice)));
     
#line 2206 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_serial_3(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilXY_serial_3()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 42 "inc/DpcppPmeSolver.ci"
 setDeviceBuffers(); 
#line 2225 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_4(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_serial_4(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilXY_serial_4()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 43 "inc/DpcppPmeSolver.ci"
 cb.send(); 
#line 2242 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::recvDeviceBuffer(DeviceDataMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CmiReference(UsrToEnv(msg_msg));
  __dep->pushBuffer(0, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::getDeviceBufferZ(int x, bool sameDevice, CProxy_DpcppPmePencilZ proxy){
  Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure* genClosure = new Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure();
  genClosure->getP0() = x;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBufferZ(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::getDeviceBufferZ(Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(1, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_sdag_init() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(2,2));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::__sdag_init() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::_sdag_pup(PUP::er &p) {  // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilXY::__sdag_register() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  (void)_sdag_idx_DpcppPmePencilXY_serial_0();
  (void)_sdag_idx_DpcppPmePencilXY_serial_1();
  (void)_sdag_idx_DpcppPmePencilXY_serial_2();
  (void)_sdag_idx_DpcppPmePencilXY_serial_3();
  (void)_sdag_idx_DpcppPmePencilXY_serial_4();
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilXY::getDeviceBufferZ_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilXY::getDeviceBuffer_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilXY::recvDeviceBuffers_7_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_idx_DpcppPmePencilXY_serial_0() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilXY_serial_0();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_reg_DpcppPmePencilXY_serial_0() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilXY_serial_0", NULL, 0, CkIndex_DpcppPmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_idx_DpcppPmePencilXY_serial_1() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilXY_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_reg_DpcppPmePencilXY_serial_1() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilXY_serial_1", NULL, 0, CkIndex_DpcppPmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_idx_DpcppPmePencilXY_serial_2() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilXY_serial_2();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_reg_DpcppPmePencilXY_serial_2() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilXY_serial_2", NULL, 0, CkIndex_DpcppPmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_idx_DpcppPmePencilXY_serial_3() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilXY_serial_3();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_reg_DpcppPmePencilXY_serial_3() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilXY_serial_3", NULL, 0, CkIndex_DpcppPmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_idx_DpcppPmePencilXY_serial_4() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilXY_serial_4();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilXY::_sdag_reg_DpcppPmePencilXY_serial_4() { // Potentially missing DpcppPmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilXY_serial_4", NULL, 0, CkIndex_DpcppPmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */




/* DEFS: array DpcppPmePencilX: PmePencilX{
DpcppPmePencilX();
void initialize(DpcppPmeXInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg* impl_msg);
void getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void recvDeviceBuffer(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilX(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_DpcppPmePencilX::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_DpcppPmePencilX::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilX::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilX::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilX::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_DpcppPmePencilX::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilX::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilX();
 */
void CProxyElement_DpcppPmePencilX::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_DpcppPmePencilX::idx_DpcppPmePencilX_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilX::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_initialize_DpcppPmeXInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilX::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_initializeDevice_InitDeviceMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxyElement_DpcppPmePencilX::getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_getDeviceBuffer2_marshall4(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxyElement_DpcppPmePencilX::getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_getDeviceBuffer_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilX::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxyElement_DpcppPmePencilX::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_recvDeviceBuffers_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilX(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilX();
 */
CkArrayID CProxy_DpcppPmePencilX::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilX::idx_DpcppPmePencilX_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilX::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilX::idx_DpcppPmePencilX_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_DpcppPmePencilX::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilX::idx_DpcppPmePencilX_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilX::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilX::idx_DpcppPmePencilX_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_DpcppPmePencilX_void() {
  int epidx = CkRegisterEp("DpcppPmePencilX()",
      _call_DpcppPmePencilX_void, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_DpcppPmePencilX_void(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  new (impl_obj_void) DpcppPmePencilX();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxy_DpcppPmePencilX::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilX::idx_initialize_DpcppPmeXInitMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_initialize_DpcppPmeXInitMsg() {
  int epidx = CkRegisterEp("initialize(DpcppPmeXInitMsg* impl_msg)",
      _call_initialize_DpcppPmeXInitMsg, CMessage_DpcppPmeXInitMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DpcppPmeXInitMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_initialize_DpcppPmeXInitMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  impl_obj->initialize((DpcppPmeXInitMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxy_DpcppPmePencilX::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilX::idx_initializeDevice_InitDeviceMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_initializeDevice_InitDeviceMsg() {
  int epidx = CkRegisterEp("initializeDevice(InitDeviceMsg* impl_msg)",
      _call_initializeDevice_InitDeviceMsg, CMessage_InitDeviceMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)InitDeviceMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_initializeDevice_InitDeviceMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  impl_obj->initializeDevice((InitDeviceMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxy_DpcppPmePencilX::getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilX::idx_getDeviceBuffer2_marshall4(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_getDeviceBuffer2_marshall4() {
  int epidx = CkRegisterEp("getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy)",
      _call_getDeviceBuffer2_marshall4, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer2_marshall4);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer2_marshall4);

  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_getDeviceBuffer2_marshall4(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure* genClosure = new Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer2(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilX::_callmarshall_getDeviceBuffer2_marshall4(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure* genClosure = new Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer2(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilX::_marshallmessagepup_getDeviceBuffer2_marshall4(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> x;
  implP|x;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilY> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("x");
  implDestP|x;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxy_DpcppPmePencilX::getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilX::idx_getDeviceBuffer_marshall5(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_getDeviceBuffer_marshall5() {
  int epidx = CkRegisterEp("getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy)",
      _call_getDeviceBuffer_marshall5, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer_marshall5);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer_marshall5);

  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_getDeviceBuffer_marshall5(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilX::getDeviceBuffer_5_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilX::_callmarshall_getDeviceBuffer_marshall5(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilX::getDeviceBuffer_5_closure();
  implP|genClosure->x;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilX::_marshallmessagepup_getDeviceBuffer_marshall5(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> x;
  implP|x;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilY> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("x");
  implDestP|x;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxy_DpcppPmePencilX::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilX::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_recvDeviceBuffer_DeviceDataMsg() {
  int epidx = CkRegisterEp("recvDeviceBuffer(DeviceDataMsg* impl_msg)",
      _call_recvDeviceBuffer_DeviceDataMsg, CMessage_DeviceDataMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DeviceDataMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_recvDeviceBuffer_DeviceDataMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  impl_obj->recvDeviceBuffer((DeviceDataMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxy_DpcppPmePencilX::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilX::idx_recvDeviceBuffers_marshall7(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_recvDeviceBuffers_marshall7() {
  int epidx = CkRegisterEp("recvDeviceBuffers(const CkCallback &cb)",
      _call_recvDeviceBuffers_marshall7, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_recvDeviceBuffers_marshall7);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_recvDeviceBuffers_marshall7);

  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_recvDeviceBuffers_marshall7(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* genClosure = new Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilX::_callmarshall_recvDeviceBuffers_marshall7(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilX* impl_obj = static_cast<DpcppPmePencilX*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* genClosure = new Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilX::_marshallmessagepup_recvDeviceBuffers_marshall7(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: const CkCallback &cb*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<CkCallback> cb;
  implP|cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("cb");
  implDestP|cb;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilX(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_DpcppPmePencilX::reg_DpcppPmePencilX_CkMigrateMessage() {
  int epidx = CkRegisterEp("DpcppPmePencilX(CkMigrateMessage* impl_msg)",
      _call_DpcppPmePencilX_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilX::_call_DpcppPmePencilX_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<DpcppPmePencilX> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilX();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilX::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_initialize_DpcppPmeXInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilX::initializeDevice(InitDeviceMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_initializeDevice_InitDeviceMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxySection_DpcppPmePencilX::getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_getDeviceBuffer2_marshall4(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxySection_DpcppPmePencilX::getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|x;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_getDeviceBuffer_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilX::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxySection_DpcppPmePencilX::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilX::idx_recvDeviceBuffers_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilX(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_DpcppPmePencilX::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_PmePencilX::__idx);
  // REG: DpcppPmePencilX();
  idx_DpcppPmePencilX_void();
  CkRegisterDefaultCtor(__idx, idx_DpcppPmePencilX_void());

  // REG: void initialize(DpcppPmeXInitMsg* impl_msg);
  idx_initialize_DpcppPmeXInitMsg();

  // REG: void initializeDevice(InitDeviceMsg* impl_msg);
  idx_initializeDevice_InitDeviceMsg();

  // REG: void getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
  idx_getDeviceBuffer2_marshall4();

  // REG: void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
  idx_getDeviceBuffer_marshall5();

  // REG: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
  idx_recvDeviceBuffer_DeviceDataMsg();

  // REG: void recvDeviceBuffers(const CkCallback &cb);
  idx_recvDeviceBuffers_marshall7();

  // REG: DpcppPmePencilX(CkMigrateMessage* impl_msg);
  idx_DpcppPmePencilX_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_DpcppPmePencilX_CkMigrateMessage());

  DpcppPmePencilX::__sdag_register(); // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::getDeviceBuffer(int x, bool sameDevice, CProxy_DpcppPmePencilY proxy){
  Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilX::getDeviceBuffer_5_closure();
  genClosure->getP0() = x;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::getDeviceBuffer(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_0(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::getDeviceBuffer_end(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_0(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_0_end(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* gen0) {
  getDeviceBuffer_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_serial_0(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilX_serial_0()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    int& x = gen0->getP0();
    bool& sameDevice = gen0->getP1();
    CProxy_DpcppPmePencilY& proxy = gen0->getP2();
    { // begin serial block
#line 53 "inc/DpcppPmeSolver.ci"

    numGetDeviceBuffer++;
    getDeviceBuffer2(x, sameDevice, proxy);
   
#line 3263 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::recvDeviceBuffers(const CkCallback & cb){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "DpcppPmePencilX", "recvDeviceBuffers(const CkCallback & cb)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_sdag_fnc_recvDeviceBuffers(const CkCallback & cb){
  Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* genClosure = new Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure();
  genClosure->getP0() = cb;
  _sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_sdag_fnc_recvDeviceBuffers(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_1(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::recvDeviceBuffers_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_1(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  _overlap_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_1_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  recvDeviceBuffers_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_overlap_0(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  _olist_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_overlap_0_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  _serial_3(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_olist_0(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  SDAG::CCounter *_co0= new SDAG::CCounter(2);
  _for_0(gen0, _co0);
  _for_1(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_olist_0_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _co0->decrement();
  if (_co0->isDone()) {
  _co0->deref();
    _overlap_0_end(gen0);
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_for_0(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgY=0;
      if (imsgY < numDeviceBuffers) {
        _slist_2(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_for_0_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      ++imsgY;
      if (imsgY < numDeviceBuffers) {
        _slist_2(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_2(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _when_0(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_2_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _for_0_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilX::_when_0(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0, _co0, static_cast<DeviceDataMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_when_0_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        CmiFree(UsrToEnv(msg));
      }
    }
  }
  _slist_2_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_serial_1(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilX_serial_1()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        { // begin serial block
#line 62 "inc/DpcppPmeSolver.ci"

      deviceBuffers[msg->i].data = msg->data;
      deviceBuffers[msg->i].event = msg->event;
      delete msg;
     
#line 3451 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_for_1(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg=0;
      if (imsg < numGetDeviceBuffer) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_for_1_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg++;
      if (imsg < numGetDeviceBuffer) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_3(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _when_1(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_slist_3_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  _for_1_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilX::_when_1(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, _co0, static_cast<Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure*>(buf0->cl));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_when_1_end(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure* gen2) {
  _slist_3_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_serial_2(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilX_serial_2()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        int& x = gen2->getP0();
        bool& sameDevice = gen2->getP1();
        CProxy_DpcppPmePencilY& proxy = gen2->getP2();
        { // begin serial block
#line 69 "inc/DpcppPmeSolver.ci"

      proxy(x,0,thisIndex.z).recvDeviceBufferX(new DeviceDataMsg(thisIndex.y, event, getData(x, sameDevice)));
     
#line 3552 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_serial_3(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilX_serial_3()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 74 "inc/DpcppPmeSolver.ci"
 setDeviceBuffers(); 
#line 3571 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_4(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_serial_4(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilX_serial_4()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 75 "inc/DpcppPmeSolver.ci"
 cb.send(); 
#line 3588 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::recvDeviceBuffer(DeviceDataMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CmiReference(UsrToEnv(msg_msg));
  __dep->pushBuffer(0, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::getDeviceBuffer2(int x, bool sameDevice, CProxy_DpcppPmePencilY proxy){
  Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure* genClosure = new Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure();
  genClosure->getP0() = x;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer2(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::getDeviceBuffer2(Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(1, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_sdag_init() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(2,2));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::__sdag_init() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::_sdag_pup(PUP::er &p) {  // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilX::__sdag_register() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  (void)_sdag_idx_DpcppPmePencilX_serial_0();
  (void)_sdag_idx_DpcppPmePencilX_serial_1();
  (void)_sdag_idx_DpcppPmePencilX_serial_2();
  (void)_sdag_idx_DpcppPmePencilX_serial_3();
  (void)_sdag_idx_DpcppPmePencilX_serial_4();
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilX::getDeviceBuffer2_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilX::getDeviceBuffer_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilX::recvDeviceBuffers_7_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_idx_DpcppPmePencilX_serial_0() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilX_serial_0();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_reg_DpcppPmePencilX_serial_0() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilX_serial_0", NULL, 0, CkIndex_DpcppPmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_idx_DpcppPmePencilX_serial_1() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilX_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_reg_DpcppPmePencilX_serial_1() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilX_serial_1", NULL, 0, CkIndex_DpcppPmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_idx_DpcppPmePencilX_serial_2() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilX_serial_2();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_reg_DpcppPmePencilX_serial_2() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilX_serial_2", NULL, 0, CkIndex_DpcppPmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_idx_DpcppPmePencilX_serial_3() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilX_serial_3();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_reg_DpcppPmePencilX_serial_3() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilX_serial_3", NULL, 0, CkIndex_DpcppPmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_idx_DpcppPmePencilX_serial_4() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilX_serial_4();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilX::_sdag_reg_DpcppPmePencilX_serial_4() { // Potentially missing DpcppPmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilX_serial_4", NULL, 0, CkIndex_DpcppPmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: array DpcppPmePencilY: PmePencilY{
DpcppPmePencilY();
void initialize(DpcppPmeXInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg2* impl_msg);
void getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
void getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void recvDeviceBufferZ(DeviceDataMsg* impl_msg);
void recvDeviceBufferX(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilY(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_DpcppPmePencilY::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_DpcppPmePencilY::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilY::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_DpcppPmePencilY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilY();
 */
void CProxyElement_DpcppPmePencilY::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_DpcppPmePencilY::idx_DpcppPmePencilY_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilY::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_initialize_DpcppPmeXInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg2* impl_msg);
 */
void CProxyElement_DpcppPmePencilY::initializeDevice(InitDeviceMsg2* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_initializeDevice_InitDeviceMsg2(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
 */
void CProxyElement_DpcppPmePencilY::getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer2_marshall4(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
 */
void CProxyElement_DpcppPmePencilY::getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxyElement_DpcppPmePencilY::getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer22_marshall6(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxyElement_DpcppPmePencilY::getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBufferZ(DeviceDataMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilY::recvDeviceBufferZ(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBufferZ_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBufferX(DeviceDataMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilY::recvDeviceBufferX(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBufferX_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxyElement_DpcppPmePencilY::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBuffers_marshall10(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilY();
 */
CkArrayID CProxy_DpcppPmePencilY::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilY::idx_DpcppPmePencilY_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilY::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilY::idx_DpcppPmePencilY_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_DpcppPmePencilY::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilY::idx_DpcppPmePencilY_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilY::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilY::idx_DpcppPmePencilY_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_DpcppPmePencilY_void() {
  int epidx = CkRegisterEp("DpcppPmePencilY()",
      _call_DpcppPmePencilY_void, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_DpcppPmePencilY_void(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  new (impl_obj_void) DpcppPmePencilY();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxy_DpcppPmePencilY::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_initialize_DpcppPmeXInitMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_initialize_DpcppPmeXInitMsg() {
  int epidx = CkRegisterEp("initialize(DpcppPmeXInitMsg* impl_msg)",
      _call_initialize_DpcppPmeXInitMsg, CMessage_DpcppPmeXInitMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DpcppPmeXInitMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_initialize_DpcppPmeXInitMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  impl_obj->initialize((DpcppPmeXInitMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg2* impl_msg);
 */
void CProxy_DpcppPmePencilY::initializeDevice(InitDeviceMsg2* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_initializeDevice_InitDeviceMsg2(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_initializeDevice_InitDeviceMsg2() {
  int epidx = CkRegisterEp("initializeDevice(InitDeviceMsg2* impl_msg)",
      _call_initializeDevice_InitDeviceMsg2, CMessage_InitDeviceMsg2::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)InitDeviceMsg2::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_initializeDevice_InitDeviceMsg2(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  impl_obj->initializeDevice((InitDeviceMsg2*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
 */
void CProxy_DpcppPmePencilY::getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer2_marshall4(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_getDeviceBuffer2_marshall4() {
  int epidx = CkRegisterEp("getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy)",
      _call_getDeviceBuffer2_marshall4, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer2_marshall4);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer2_marshall4);

  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_getDeviceBuffer2_marshall4(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer2(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilY::_callmarshall_getDeviceBuffer2_marshall4(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer2(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilY::_marshallmessagepup_getDeviceBuffer2_marshall4(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> y;
  implP|y;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilX> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("y");
  implDestP|y;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
 */
void CProxy_DpcppPmePencilY::getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer_marshall5(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_getDeviceBuffer_marshall5() {
  int epidx = CkRegisterEp("getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy)",
      _call_getDeviceBuffer_marshall5, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer_marshall5);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer_marshall5);

  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_getDeviceBuffer_marshall5(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer_5_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilY::_callmarshall_getDeviceBuffer_marshall5(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer_5_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilY::_marshallmessagepup_getDeviceBuffer_marshall5(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> y;
  implP|y;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilX> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("y");
  implDestP|y;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxy_DpcppPmePencilY::getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer22_marshall6(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_getDeviceBuffer22_marshall6() {
  int epidx = CkRegisterEp("getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy)",
      _call_getDeviceBuffer22_marshall6, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer22_marshall6);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer22_marshall6);

  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_getDeviceBuffer22_marshall6(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer22(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilY::_callmarshall_getDeviceBuffer22_marshall6(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer22(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilY::_marshallmessagepup_getDeviceBuffer22_marshall6(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> y;
  implP|y;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilZ> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("y");
  implDestP|y;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxy_DpcppPmePencilY::getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer_marshall7(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_getDeviceBuffer_marshall7() {
  int epidx = CkRegisterEp("getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy)",
      _call_getDeviceBuffer_marshall7, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer_marshall7);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer_marshall7);

  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_getDeviceBuffer_marshall7(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer_7_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilY::_callmarshall_getDeviceBuffer_marshall7(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer_7_closure();
  implP|genClosure->y;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilY::_marshallmessagepup_getDeviceBuffer_marshall7(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> y;
  implP|y;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilZ> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("y");
  implDestP|y;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBufferZ(DeviceDataMsg* impl_msg);
 */
void CProxy_DpcppPmePencilY::recvDeviceBufferZ(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBufferZ_DeviceDataMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_recvDeviceBufferZ_DeviceDataMsg() {
  int epidx = CkRegisterEp("recvDeviceBufferZ(DeviceDataMsg* impl_msg)",
      _call_recvDeviceBufferZ_DeviceDataMsg, CMessage_DeviceDataMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DeviceDataMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_recvDeviceBufferZ_DeviceDataMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  impl_obj->recvDeviceBufferZ((DeviceDataMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBufferX(DeviceDataMsg* impl_msg);
 */
void CProxy_DpcppPmePencilY::recvDeviceBufferX(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBufferX_DeviceDataMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_recvDeviceBufferX_DeviceDataMsg() {
  int epidx = CkRegisterEp("recvDeviceBufferX(DeviceDataMsg* impl_msg)",
      _call_recvDeviceBufferX_DeviceDataMsg, CMessage_DeviceDataMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DeviceDataMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_recvDeviceBufferX_DeviceDataMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  impl_obj->recvDeviceBufferX((DeviceDataMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxy_DpcppPmePencilY::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBuffers_marshall10(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_recvDeviceBuffers_marshall10() {
  int epidx = CkRegisterEp("recvDeviceBuffers(const CkCallback &cb)",
      _call_recvDeviceBuffers_marshall10, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_recvDeviceBuffers_marshall10);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_recvDeviceBuffers_marshall10);

  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_recvDeviceBuffers_marshall10(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* genClosure = new Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilY::_callmarshall_recvDeviceBuffers_marshall10(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilY* impl_obj = static_cast<DpcppPmePencilY*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* genClosure = new Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilY::_marshallmessagepup_recvDeviceBuffers_marshall10(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: const CkCallback &cb*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<CkCallback> cb;
  implP|cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("cb");
  implDestP|cb;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilY(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_DpcppPmePencilY::reg_DpcppPmePencilY_CkMigrateMessage() {
  int epidx = CkRegisterEp("DpcppPmePencilY(CkMigrateMessage* impl_msg)",
      _call_DpcppPmePencilY_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilY::_call_DpcppPmePencilY_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<DpcppPmePencilY> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilY();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilY::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_initialize_DpcppPmeXInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg2* impl_msg);
 */
void CProxySection_DpcppPmePencilY::initializeDevice(InitDeviceMsg2* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_initializeDevice_InitDeviceMsg2(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
 */
void CProxySection_DpcppPmePencilY::getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer2_marshall4(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
 */
void CProxySection_DpcppPmePencilY::getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilX>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxySection_DpcppPmePencilY::getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer22_marshall6(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
 */
void CProxySection_DpcppPmePencilY::getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|y;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilZ>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_getDeviceBuffer_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBufferZ(DeviceDataMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilY::recvDeviceBufferZ(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBufferZ_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBufferX(DeviceDataMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilY::recvDeviceBufferX(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBufferX_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxySection_DpcppPmePencilY::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilY::idx_recvDeviceBuffers_marshall10(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_DpcppPmePencilY::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_PmePencilY::__idx);
  // REG: DpcppPmePencilY();
  idx_DpcppPmePencilY_void();
  CkRegisterDefaultCtor(__idx, idx_DpcppPmePencilY_void());

  // REG: void initialize(DpcppPmeXInitMsg* impl_msg);
  idx_initialize_DpcppPmeXInitMsg();

  // REG: void initializeDevice(InitDeviceMsg2* impl_msg);
  idx_initializeDevice_InitDeviceMsg2();

  // REG: void getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
  idx_getDeviceBuffer2_marshall4();

  // REG: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
  idx_getDeviceBuffer_marshall5();

  // REG: void getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
  idx_getDeviceBuffer22_marshall6();

  // REG: void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
  idx_getDeviceBuffer_marshall7();

  // REG: void recvDeviceBufferZ(DeviceDataMsg* impl_msg);
  idx_recvDeviceBufferZ_DeviceDataMsg();

  // REG: void recvDeviceBufferX(DeviceDataMsg* impl_msg);
  idx_recvDeviceBufferX_DeviceDataMsg();

  // REG: void recvDeviceBuffers(const CkCallback &cb);
  idx_recvDeviceBuffers_marshall10();

  // REG: DpcppPmePencilY(CkMigrateMessage* impl_msg);
  idx_DpcppPmePencilY_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_DpcppPmePencilY_CkMigrateMessage());

  DpcppPmePencilY::__sdag_register(); // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer(int y, bool sameDevice, CProxy_DpcppPmePencilX proxy){
  Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer_5_closure();
  genClosure->getP0() = y;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_0(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer_end(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_0(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_0_end(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* gen0) {
  getDeviceBuffer_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_0(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_0()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    int& y = gen0->getP0();
    bool& sameDevice = gen0->getP1();
    CProxy_DpcppPmePencilX& proxy = gen0->getP2();
    { // begin serial block
#line 84 "inc/DpcppPmeSolver.ci"

    numGetDeviceBufferX++;
    getDeviceBuffer2(y, sameDevice, proxy);
   
#line 4993 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer(int y, bool sameDevice, CProxy_DpcppPmePencilZ proxy){
  Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer_7_closure();
  genClosure->getP0() = y;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_1(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer_end(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_1(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* gen0) {
  _serial_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_1_end(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* gen0) {
  getDeviceBuffer_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_1(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_1()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    int& y = gen0->getP0();
    bool& sameDevice = gen0->getP1();
    CProxy_DpcppPmePencilZ& proxy = gen0->getP2();
    { // begin serial block
#line 91 "inc/DpcppPmeSolver.ci"

    numGetDeviceBufferZ++;
    getDeviceBuffer22(y, sameDevice, proxy);
   
#line 5056 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::recvDeviceBuffers(const CkCallback & cb){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "DpcppPmePencilY", "recvDeviceBuffers(const CkCallback & cb)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_sdag_fnc_recvDeviceBuffers(const CkCallback & cb){
  Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* genClosure = new Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure();
  genClosure->getP0() = cb;
  _sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_sdag_fnc_recvDeviceBuffers(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_2(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::recvDeviceBuffers_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_2(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  _overlap_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_2_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  recvDeviceBuffers_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_overlap_0(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  _olist_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_overlap_0_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  _serial_6(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_olist_0(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  SDAG::CCounter *_co0= new SDAG::CCounter(4);
  _for_0(gen0, _co0);
  _for_1(gen0, _co0);
  _for_2(gen0, _co0);
  _for_3(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_olist_0_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _co0->decrement();
  if (_co0->isDone()) {
  _co0->deref();
    _overlap_0_end(gen0);
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_0(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgZ=0;
      if (imsgZ < numDeviceBuffersZ) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_0_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      ++imsgZ;
      if (imsgZ < numDeviceBuffersZ) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_3(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_0(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_3_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_0_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilY::_when_0(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, _co0, static_cast<DeviceDataMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_when_0_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        CmiFree(UsrToEnv(msg));
      }
    }
  }
  _slist_3_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_2(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_2()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        { // begin serial block
#line 101 "inc/DpcppPmeSolver.ci"

      deviceBuffersZ[msg->i].data = msg->data;
      deviceBuffersZ[msg->i].event = msg->event;
      delete msg;
     
#line 5246 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_1(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgX=0;
      if (imsgX < numDeviceBuffersX) {
        _slist_4(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_1_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      ++imsgX;
      if (imsgX < numDeviceBuffersX) {
        _slist_4(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_4(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_1(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_4_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_1_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilY::_when_1(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_3(gen0, _co0, static_cast<DeviceDataMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_when_1_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        CmiFree(UsrToEnv(msg));
      }
    }
  }
  _slist_4_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_3(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_3()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        { // begin serial block
#line 108 "inc/DpcppPmeSolver.ci"

      deviceBuffersX[msg->i].data = msg->data;
      deviceBuffersX[msg->i].event = msg->event;
      delete msg;
     
#line 5356 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_2(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgXX=0;
      if (imsgXX < numGetDeviceBufferX) {
        _slist_5(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_2_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgXX++;
      if (imsgXX < numGetDeviceBufferX) {
        _slist_5(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_5(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_2(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_5_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_2_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilY::_when_2(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(2, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_4(gen0, _co0, static_cast<Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure*>(buf0->cl));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(2);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(2);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_when_2_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure* gen2) {
  _slist_5_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_4(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_4()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        int& y = gen2->getP0();
        bool& sameDevice = gen2->getP1();
        CProxy_DpcppPmePencilX& proxy = gen2->getP2();
        { // begin serial block
#line 115 "inc/DpcppPmeSolver.ci"

      proxy(0,y,thisIndex.z).recvDeviceBuffer(new DeviceDataMsg(thisIndex.x, event, getDataForX(y, sameDevice)));
     
#line 5457 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_2_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_3(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgZZ=0;
      if (imsgZZ < numGetDeviceBufferZ) {
        _slist_6(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_for_3_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgZZ++;
      if (imsgZZ < numGetDeviceBufferZ) {
        _slist_6(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_6(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_3(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_slist_6_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_3_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilY::_when_3(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(3, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_5(gen0, _co0, static_cast<Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure*>(buf0->cl));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(3);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(3);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_when_3_end(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure* gen2) {
  _slist_6_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_5(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_5()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        int& y = gen2->getP0();
        bool& sameDevice = gen2->getP1();
        CProxy_DpcppPmePencilZ& proxy = gen2->getP2();
        { // begin serial block
#line 120 "inc/DpcppPmeSolver.ci"

      proxy(thisIndex.x,y,0).recvDeviceBuffer(new DeviceDataMsg(thisIndex.z, event, getDataForZ(y, sameDevice)));
     
#line 5558 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_3_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_6(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_6()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 125 "inc/DpcppPmeSolver.ci"
 setDeviceBuffers(); 
#line 5577 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_7(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_serial_7(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilY_serial_7()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 126 "inc/DpcppPmeSolver.ci"
 cb.send(); 
#line 5594 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_2_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::recvDeviceBufferZ(DeviceDataMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CmiReference(UsrToEnv(msg_msg));
  __dep->pushBuffer(0, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::recvDeviceBufferX(DeviceDataMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CmiReference(UsrToEnv(msg_msg));
  __dep->pushBuffer(1, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer2(int y, bool sameDevice, CProxy_DpcppPmePencilX proxy){
  Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure();
  genClosure->getP0() = y;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer2(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer2(Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(2, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(2);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_2(
      static_cast<Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer22(int y, bool sameDevice, CProxy_DpcppPmePencilZ proxy){
  Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure* genClosure = new Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure();
  genClosure->getP0() = y;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer22(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::getDeviceBuffer22(Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(3, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(3);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_3(
      static_cast<Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_sdag_init() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(4,4));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
  __dep->addDepends(2,2);
  __dep->addDepends(3,3);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::__sdag_init() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::_sdag_pup(PUP::er &p) {  // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilY::__sdag_register() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  (void)_sdag_idx_DpcppPmePencilY_serial_0();
  (void)_sdag_idx_DpcppPmePencilY_serial_1();
  (void)_sdag_idx_DpcppPmePencilY_serial_2();
  (void)_sdag_idx_DpcppPmePencilY_serial_3();
  (void)_sdag_idx_DpcppPmePencilY_serial_4();
  (void)_sdag_idx_DpcppPmePencilY_serial_5();
  (void)_sdag_idx_DpcppPmePencilY_serial_6();
  (void)_sdag_idx_DpcppPmePencilY_serial_7();
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer2_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer22_6_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::getDeviceBuffer_7_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilY::recvDeviceBuffers_10_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_0() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_0();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_0() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_0", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_1() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_1() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_1", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_2() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_2();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_2() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_2", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_3() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_3();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_3() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_3", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_4() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_4();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_4() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_4", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_5() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_5();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_5() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_5", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_6() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_6();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_6() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_6", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_idx_DpcppPmePencilY_serial_7() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilY_serial_7();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilY::_sdag_reg_DpcppPmePencilY_serial_7() { // Potentially missing DpcppPmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilY_serial_7", NULL, 0, CkIndex_DpcppPmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: array DpcppPmePencilZ: PmePencilZ{
DpcppPmePencilZ();
void initialize(DpcppPmeXInitMsg* impl_msg);
void initialize(DpcppPmeXYInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg2* impl_msg);
void getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
void getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void recvDeviceBuffer(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilZ(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_DpcppPmePencilZ::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_DpcppPmePencilZ::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_DpcppPmePencilZ::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_DpcppPmePencilZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_DpcppPmePencilZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilZ();
 */
void CProxyElement_DpcppPmePencilZ::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_DpcppPmePencilZ::idx_DpcppPmePencilZ_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilZ::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initialize_DpcppPmeXInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYInitMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilZ::initialize(DpcppPmeXYInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initialize_DpcppPmeXYInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg2* impl_msg);
 */
void CProxyElement_DpcppPmePencilZ::initializeDevice(InitDeviceMsg2* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initializeDevice_InitDeviceMsg2(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
 */
void CProxyElement_DpcppPmePencilZ::getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBufferXY_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
 */
void CProxyElement_DpcppPmePencilZ::getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBuffer_marshall6(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxyElement_DpcppPmePencilZ::getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBufferY_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxyElement_DpcppPmePencilZ::getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBuffer_marshall8(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxyElement_DpcppPmePencilZ::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxyElement_DpcppPmePencilZ::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_recvDeviceBuffers_marshall10(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilZ();
 */
CkArrayID CProxy_DpcppPmePencilZ::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilZ::idx_DpcppPmePencilZ_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilZ::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilZ::idx_DpcppPmePencilZ_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_DpcppPmePencilZ::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_DpcppPmePencilZ::idx_DpcppPmePencilZ_void(), opts);
  return gId;
}
void CProxy_DpcppPmePencilZ::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_DpcppPmePencilZ::idx_DpcppPmePencilZ_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_DpcppPmePencilZ_void() {
  int epidx = CkRegisterEp("DpcppPmePencilZ()",
      _call_DpcppPmePencilZ_void, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_DpcppPmePencilZ_void(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  new (impl_obj_void) DpcppPmePencilZ();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxy_DpcppPmePencilZ::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initialize_DpcppPmeXInitMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_initialize_DpcppPmeXInitMsg() {
  int epidx = CkRegisterEp("initialize(DpcppPmeXInitMsg* impl_msg)",
      _call_initialize_DpcppPmeXInitMsg, CMessage_DpcppPmeXInitMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DpcppPmeXInitMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_initialize_DpcppPmeXInitMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  impl_obj->initialize((DpcppPmeXInitMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYInitMsg* impl_msg);
 */
void CProxy_DpcppPmePencilZ::initialize(DpcppPmeXYInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initialize_DpcppPmeXYInitMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_initialize_DpcppPmeXYInitMsg() {
  int epidx = CkRegisterEp("initialize(DpcppPmeXYInitMsg* impl_msg)",
      _call_initialize_DpcppPmeXYInitMsg, CMessage_DpcppPmeXYInitMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DpcppPmeXYInitMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_initialize_DpcppPmeXYInitMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  impl_obj->initialize((DpcppPmeXYInitMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg2* impl_msg);
 */
void CProxy_DpcppPmePencilZ::initializeDevice(InitDeviceMsg2* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initializeDevice_InitDeviceMsg2(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_initializeDevice_InitDeviceMsg2() {
  int epidx = CkRegisterEp("initializeDevice(InitDeviceMsg2* impl_msg)",
      _call_initializeDevice_InitDeviceMsg2, CMessage_InitDeviceMsg2::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)InitDeviceMsg2::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_initializeDevice_InitDeviceMsg2(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  impl_obj->initializeDevice((InitDeviceMsg2*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
 */
void CProxy_DpcppPmePencilZ::getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBufferXY_marshall5(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_getDeviceBufferXY_marshall5() {
  int epidx = CkRegisterEp("getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy)",
      _call_getDeviceBufferXY_marshall5, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBufferXY_marshall5);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBufferXY_marshall5);

  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_getDeviceBufferXY_marshall5(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBufferXY(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilZ::_callmarshall_getDeviceBufferXY_marshall5(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBufferXY(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilZ::_marshallmessagepup_getDeviceBufferXY_marshall5(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> z;
  implP|z;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilXY> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("z");
  implDestP|z;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
 */
void CProxy_DpcppPmePencilZ::getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBuffer_marshall6(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_getDeviceBuffer_marshall6() {
  int epidx = CkRegisterEp("getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy)",
      _call_getDeviceBuffer_marshall6, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer_marshall6);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer_marshall6);

  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_getDeviceBuffer_marshall6(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilZ::_callmarshall_getDeviceBuffer_marshall6(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilZ::_marshallmessagepup_getDeviceBuffer_marshall6(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> z;
  implP|z;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilXY> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("z");
  implDestP|z;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxy_DpcppPmePencilZ::getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBufferY_marshall7(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_getDeviceBufferY_marshall7() {
  int epidx = CkRegisterEp("getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy)",
      _call_getDeviceBufferY_marshall7, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBufferY_marshall7);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBufferY_marshall7);

  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_getDeviceBufferY_marshall7(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBufferY(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilZ::_callmarshall_getDeviceBufferY_marshall7(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBufferY(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilZ::_marshallmessagepup_getDeviceBufferY_marshall7(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> z;
  implP|z;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilY> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("z");
  implDestP|z;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxy_DpcppPmePencilZ::getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBuffer_marshall8(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_getDeviceBuffer_marshall8() {
  int epidx = CkRegisterEp("getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy)",
      _call_getDeviceBuffer_marshall8, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_getDeviceBuffer_marshall8);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getDeviceBuffer_marshall8);

  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_getDeviceBuffer_marshall8(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilZ::_callmarshall_getDeviceBuffer_marshall8(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure();
  implP|genClosure->z;
  implP|genClosure->sameDevice;
  implP|genClosure->proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->getDeviceBuffer(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilZ::_marshallmessagepup_getDeviceBuffer_marshall8(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> z;
  implP|z;
  PUP::detail::TemporaryObjectHolder<bool> sameDevice;
  implP|sameDevice;
  PUP::detail::TemporaryObjectHolder<CProxy_DpcppPmePencilY> proxy;
  implP|proxy;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("z");
  implDestP|z;
  if (implDestP.hasComments()) implDestP.comment("sameDevice");
  implDestP|sameDevice;
  if (implDestP.hasComments()) implDestP.comment("proxy");
  implDestP|proxy;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxy_DpcppPmePencilZ::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_recvDeviceBuffer_DeviceDataMsg() {
  int epidx = CkRegisterEp("recvDeviceBuffer(DeviceDataMsg* impl_msg)",
      _call_recvDeviceBuffer_DeviceDataMsg, CMessage_DeviceDataMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)DeviceDataMsg::ckDebugPup);
  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_recvDeviceBuffer_DeviceDataMsg(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  impl_obj->recvDeviceBuffer((DeviceDataMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxy_DpcppPmePencilZ::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_DpcppPmePencilZ::idx_recvDeviceBuffers_marshall10(),0);
}

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_recvDeviceBuffers_marshall10() {
  int epidx = CkRegisterEp("recvDeviceBuffers(const CkCallback &cb)",
      _call_recvDeviceBuffers_marshall10, CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_recvDeviceBuffers_marshall10);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_recvDeviceBuffers_marshall10);

  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_recvDeviceBuffers_marshall10(void* impl_msg, void* impl_obj_void)
{
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* genClosure = new Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}
int CkIndex_DpcppPmePencilZ::_callmarshall_recvDeviceBuffers_marshall10(char* impl_buf, void* impl_obj_void) {
  DpcppPmePencilZ* impl_obj = static_cast<DpcppPmePencilZ*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  PUP::fromMem implP(impl_buf);
  Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* genClosure = new Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure();
  implP|genClosure->cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  impl_obj->_sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
  return implP.size();
}
void CkIndex_DpcppPmePencilZ::_marshallmessagepup_recvDeviceBuffers_marshall10(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: const CkCallback &cb*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<CkCallback> cb;
  implP|cb;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("cb");
  implDestP|cb;
}
PUPable_def(SINGLE_ARG(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilZ(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_DpcppPmePencilZ::reg_DpcppPmePencilZ_CkMigrateMessage() {
  int epidx = CkRegisterEp("DpcppPmePencilZ(CkMigrateMessage* impl_msg)",
      _call_DpcppPmePencilZ_CkMigrateMessage, 0, __idx, 0);
  return epidx;
}

void CkIndex_DpcppPmePencilZ::_call_DpcppPmePencilZ_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<DpcppPmePencilZ> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilZ();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXInitMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilZ::initialize(DpcppPmeXInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initialize_DpcppPmeXInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initialize(DpcppPmeXYInitMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilZ::initialize(DpcppPmeXYInitMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initialize_DpcppPmeXYInitMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void initializeDevice(InitDeviceMsg2* impl_msg);
 */
void CProxySection_DpcppPmePencilZ::initializeDevice(InitDeviceMsg2* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_initializeDevice_InitDeviceMsg2(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
 */
void CProxySection_DpcppPmePencilZ::getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBufferXY_marshall5(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
 */
void CProxySection_DpcppPmePencilZ::getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilXY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBuffer_marshall6(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxySection_DpcppPmePencilZ::getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBufferY_marshall7(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
 */
void CProxySection_DpcppPmePencilZ::getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|z;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)sameDevice;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CProxy_DpcppPmePencilY>::type>::type &)proxy;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_getDeviceBuffer_marshall8(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
 */
void CProxySection_DpcppPmePencilZ::recvDeviceBuffer(DeviceDataMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_recvDeviceBuffer_DeviceDataMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvDeviceBuffers(const CkCallback &cb);
 */
void CProxySection_DpcppPmePencilZ::recvDeviceBuffers(const CkCallback &cb, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: const CkCallback &cb
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<CkCallback>::type>::type &)cb;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_DpcppPmePencilZ::idx_recvDeviceBuffers_marshall10(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: DpcppPmePencilZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_DpcppPmePencilZ::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_PmePencilZ::__idx);
  // REG: DpcppPmePencilZ();
  idx_DpcppPmePencilZ_void();
  CkRegisterDefaultCtor(__idx, idx_DpcppPmePencilZ_void());

  // REG: void initialize(DpcppPmeXInitMsg* impl_msg);
  idx_initialize_DpcppPmeXInitMsg();

  // REG: void initialize(DpcppPmeXYInitMsg* impl_msg);
  idx_initialize_DpcppPmeXYInitMsg();

  // REG: void initializeDevice(InitDeviceMsg2* impl_msg);
  idx_initializeDevice_InitDeviceMsg2();

  // REG: void getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
  idx_getDeviceBufferXY_marshall5();

  // REG: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
  idx_getDeviceBuffer_marshall6();

  // REG: void getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
  idx_getDeviceBufferY_marshall7();

  // REG: void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
  idx_getDeviceBuffer_marshall8();

  // REG: void recvDeviceBuffer(DeviceDataMsg* impl_msg);
  idx_recvDeviceBuffer_DeviceDataMsg();

  // REG: void recvDeviceBuffers(const CkCallback &cb);
  idx_recvDeviceBuffers_marshall10();

  // REG: DpcppPmePencilZ(CkMigrateMessage* impl_msg);
  idx_DpcppPmePencilZ_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_DpcppPmePencilZ_CkMigrateMessage());

  DpcppPmePencilZ::__sdag_register(); // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBuffer(int z, bool sameDevice, CProxy_DpcppPmePencilXY proxy){
  Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure();
  genClosure->getP0() = z;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBuffer(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_0(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBuffer_end(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_0(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_0_end(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* gen0) {
  getDeviceBuffer_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_0(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_0()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    int& z = gen0->getP0();
    bool& sameDevice = gen0->getP1();
    CProxy_DpcppPmePencilXY& proxy = gen0->getP2();
    { // begin serial block
#line 136 "inc/DpcppPmeSolver.ci"

    numGetDeviceBufferXY++;
    getDeviceBufferXY(z, sameDevice, proxy);
   
#line 7099 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBuffer(int z, bool sameDevice, CProxy_DpcppPmePencilY proxy){
  Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure();
  genClosure->getP0() = z;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBuffer(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBuffer(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_1(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBuffer_end(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_1(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* gen0) {
  _serial_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_1_end(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* gen0) {
  getDeviceBuffer_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_1(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_1()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    int& z = gen0->getP0();
    bool& sameDevice = gen0->getP1();
    CProxy_DpcppPmePencilY& proxy = gen0->getP2();
    { // begin serial block
#line 143 "inc/DpcppPmeSolver.ci"

    numGetDeviceBufferY++;
    getDeviceBufferY(z, sameDevice, proxy);
   
#line 7162 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::recvDeviceBuffers(const CkCallback & cb){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "DpcppPmePencilZ", "recvDeviceBuffers(const CkCallback & cb)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_sdag_fnc_recvDeviceBuffers(const CkCallback & cb){
  Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* genClosure = new Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure();
  genClosure->getP0() = cb;
  _sdag_fnc_recvDeviceBuffers(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_sdag_fnc_recvDeviceBuffers(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  _slist_2(gen0);
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::recvDeviceBuffers_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_2(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  _overlap_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_2_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  recvDeviceBuffers_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_overlap_0(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  _olist_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_overlap_0_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  _serial_5(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_olist_0(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  SDAG::CCounter *_co0= new SDAG::CCounter(3);
  _for_0(gen0, _co0);
  _for_1(gen0, _co0);
  _for_2(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_olist_0_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _co0->decrement();
  if (_co0->isDone()) {
  _co0->deref();
    _overlap_0_end(gen0);
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_for_0(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsgY=0;
      if (imsgY < numDeviceBuffers) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_for_0_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      ++imsgY;
      if (imsgY < numDeviceBuffers) {
        _slist_3(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_3(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_0(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_3_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_0_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilZ::_when_0(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, _co0, static_cast<DeviceDataMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_when_0_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        CmiFree(UsrToEnv(msg));
      }
    }
  }
  _slist_3_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_2(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, DeviceDataMsg* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_2()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        DeviceDataMsg*& msg = gen2;
        { // begin serial block
#line 152 "inc/DpcppPmeSolver.ci"

      deviceBuffers[msg->i].data = msg->data;
      deviceBuffers[msg->i].event = msg->event;
      delete msg;
     
#line 7351 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_for_1(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg=0;
      if (imsg < numGetDeviceBufferY) {
        _slist_4(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_for_1_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg++;
      if (imsg < numGetDeviceBufferY) {
        _slist_4(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_4(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_1(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_4_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_1_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilZ::_when_1(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_3(gen0, _co0, static_cast<Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure*>(buf0->cl));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_when_1_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure* gen2) {
  _slist_4_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_3(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_3()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        int& z = gen2->getP0();
        bool& sameDevice = gen2->getP1();
        CProxy_DpcppPmePencilY& proxy = gen2->getP2();
        { // begin serial block
#line 159 "inc/DpcppPmeSolver.ci"

      proxy(thisIndex.x,0,z).recvDeviceBufferZ(new DeviceDataMsg(thisIndex.y, event, getData(z, sameDevice)));
     
#line 7452 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_for_2(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg=0;
      if (imsg < numGetDeviceBufferXY) {
        _slist_5(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_for_2_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  {
    CkCallback& cb = gen0->getP0();
    {
      imsg++;
      if (imsg < numGetDeviceBufferXY) {
        _slist_5(gen0, _co0);
      } else {
        _olist_0_end(gen0, _co0);
      }
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_5(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _when_2(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_slist_5_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  _for_2_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* DpcppPmePencilZ::_when_2(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(2, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_4(gen0, _co0, static_cast<Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure*>(buf0->cl));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(2);
    c->addClosure(gen0);
    c->addClosure(_co0);
    c->anyEntries.push_back(2);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_when_2_end(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure* gen2) {
  _slist_5_end(gen0, _co0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_4(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0, SDAG::CCounter* _co0, Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure* gen2) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_4()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    {
      {
        int& z = gen2->getP0();
        bool& sameDevice = gen2->getP1();
        CProxy_DpcppPmePencilXY& proxy = gen2->getP2();
        { // begin serial block
#line 164 "inc/DpcppPmeSolver.ci"

      proxy(0,0,z).recvDeviceBuffer(new DeviceDataMsg(thisIndex.x, event, getData(z, sameDevice)));
     
#line 7553 "DpcppPmeSolver.def.h"
        } // end serial block
      }
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_2_end(gen0, _co0, gen2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_5(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_5()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 169 "inc/DpcppPmeSolver.ci"
 setDeviceBuffers(); 
#line 7572 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_6(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_serial_6(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure* gen0) {
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_DpcppPmePencilZ_serial_6()), CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
  {
    CkCallback& cb = gen0->getP0();
    { // begin serial block
#line 170 "inc/DpcppPmeSolver.ci"
 cb.send(); 
#line 7589 "DpcppPmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_2_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::recvDeviceBuffer(DeviceDataMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CmiReference(UsrToEnv(msg_msg));
  __dep->pushBuffer(0, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBufferY(int z, bool sameDevice, CProxy_DpcppPmePencilY proxy){
  Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure();
  genClosure->getP0() = z;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBufferY(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBufferY(Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(1, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBufferXY(int z, bool sameDevice, CProxy_DpcppPmePencilXY proxy){
  Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure* genClosure = new Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure();
  genClosure->getP0() = z;
  genClosure->getP1() = sameDevice;
  genClosure->getP2() = proxy;
  getDeviceBufferXY(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::getDeviceBufferXY(Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(2, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(2);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_2(
      static_cast<Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure*>(c->closure[0]), 
      static_cast<SDAG::CCounter*>(c->closure[1])
    );
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, ckGetArrayIndex().getProjectionID(), this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_sdag_init() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(3,3));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
  __dep->addDepends(2,2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::__sdag_init() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::_sdag_pup(PUP::er &p) {  // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void DpcppPmePencilZ::__sdag_register() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  (void)_sdag_idx_DpcppPmePencilZ_serial_0();
  (void)_sdag_idx_DpcppPmePencilZ_serial_1();
  (void)_sdag_idx_DpcppPmePencilZ_serial_2();
  (void)_sdag_idx_DpcppPmePencilZ_serial_3();
  (void)_sdag_idx_DpcppPmePencilZ_serial_4();
  (void)_sdag_idx_DpcppPmePencilZ_serial_5();
  (void)_sdag_idx_DpcppPmePencilZ_serial_6();
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBufferXY_5_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBuffer_6_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBufferY_7_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::getDeviceBuffer_8_closure));
  PUPable_reg(SINGLE_ARG(Closure_DpcppPmePencilZ::recvDeviceBuffers_10_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_0() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_0();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_0() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_0", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_1() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_1() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_1", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_2() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_2();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_2() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_2", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_3() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_3();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_3() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_3", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_4() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_4();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_4() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_4", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_5() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_5();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_5() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_5", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_idx_DpcppPmePencilZ_serial_6() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_DpcppPmePencilZ_serial_6();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int DpcppPmePencilZ::_sdag_reg_DpcppPmePencilZ_serial_6() { // Potentially missing DpcppPmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("DpcppPmePencilZ_serial_6", NULL, 0, CkIndex_DpcppPmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



#ifndef CK_TEMPLATES_ONLY
void _registerDpcppPmeSolver(void)
{
  static int _done = 0; if(_done) return; _done = 1;
  _registerPmeSolver();

/* REG: message DpcppPmeXYZInitMsg;
*/
CMessage_DpcppPmeXYZInitMsg::__register("DpcppPmeXYZInitMsg", sizeof(DpcppPmeXYZInitMsg),(CkPackFnPtr) DpcppPmeXYZInitMsg::pack,(CkUnpackFnPtr) DpcppPmeXYZInitMsg::unpack);

/* REG: message DpcppPmeXYInitMsg;
*/
CMessage_DpcppPmeXYInitMsg::__register("DpcppPmeXYInitMsg", sizeof(DpcppPmeXYInitMsg),(CkPackFnPtr) DpcppPmeXYInitMsg::pack,(CkUnpackFnPtr) DpcppPmeXYInitMsg::unpack);

/* REG: message DpcppPmeXInitMsg;
*/
CMessage_DpcppPmeXInitMsg::__register("DpcppPmeXInitMsg", sizeof(DpcppPmeXInitMsg),(CkPackFnPtr) DpcppPmeXInitMsg::pack,(CkUnpackFnPtr) DpcppPmeXInitMsg::unpack);

/* REG: message InitDeviceMsg;
*/
CMessage_InitDeviceMsg::__register("InitDeviceMsg", sizeof(InitDeviceMsg),(CkPackFnPtr) InitDeviceMsg::pack,(CkUnpackFnPtr) InitDeviceMsg::unpack);

/* REG: message InitDeviceMsg2;
*/
CMessage_InitDeviceMsg2::__register("InitDeviceMsg2", sizeof(InitDeviceMsg2),(CkPackFnPtr) InitDeviceMsg2::pack,(CkUnpackFnPtr) InitDeviceMsg2::unpack);

/* REG: message DeviceDataMsg;
*/
CMessage_DeviceDataMsg::__register("DeviceDataMsg", sizeof(DeviceDataMsg),(CkPackFnPtr) DeviceDataMsg::pack,(CkUnpackFnPtr) DeviceDataMsg::unpack);

/* REG: array DpcppPmePencilXYZ: PmePencilXYZ{
DpcppPmePencilXYZ();
void initialize(DpcppPmeXYZInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg* impl_msg);
DpcppPmePencilXYZ(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_DpcppPmePencilXYZ::__register("DpcppPmePencilXYZ", sizeof(DpcppPmePencilXYZ));


/* REG: array DpcppPmePencilXY: PmePencilXY{
DpcppPmePencilXY();
void initialize(DpcppPmeXYInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg* impl_msg);
void getDeviceBufferZ(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void recvDeviceBuffer(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilXY(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_DpcppPmePencilXY::__register("DpcppPmePencilXY", sizeof(DpcppPmePencilXY));


/* REG: array DpcppPmePencilX: PmePencilX{
DpcppPmePencilX();
void initialize(DpcppPmeXInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg* impl_msg);
void getDeviceBuffer2(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void getDeviceBuffer(int x, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void recvDeviceBuffer(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilX(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_DpcppPmePencilX::__register("DpcppPmePencilX", sizeof(DpcppPmePencilX));

/* REG: array DpcppPmePencilY: PmePencilY{
DpcppPmePencilY();
void initialize(DpcppPmeXInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg2* impl_msg);
void getDeviceBuffer2(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilX &proxy);
void getDeviceBuffer22(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void getDeviceBuffer(int y, const bool &sameDevice, const CProxy_DpcppPmePencilZ &proxy);
void recvDeviceBufferZ(DeviceDataMsg* impl_msg);
void recvDeviceBufferX(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilY(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_DpcppPmePencilY::__register("DpcppPmePencilY", sizeof(DpcppPmePencilY));

/* REG: array DpcppPmePencilZ: PmePencilZ{
DpcppPmePencilZ();
void initialize(DpcppPmeXInitMsg* impl_msg);
void initialize(DpcppPmeXYInitMsg* impl_msg);
void initializeDevice(InitDeviceMsg2* impl_msg);
void getDeviceBufferXY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilXY &proxy);
void getDeviceBufferY(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void getDeviceBuffer(int z, const bool &sameDevice, const CProxy_DpcppPmePencilY &proxy);
void recvDeviceBuffer(DeviceDataMsg* impl_msg);
void recvDeviceBuffers(const CkCallback &cb);
DpcppPmePencilZ(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_DpcppPmePencilZ::__register("DpcppPmePencilZ", sizeof(DpcppPmePencilZ));

}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_DpcppPmePencilXYZ::virtual_pup(PUP::er &p) {
    recursive_pup<DpcppPmePencilXYZ>(dynamic_cast<DpcppPmePencilXYZ*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_DpcppPmePencilXY::virtual_pup(PUP::er &p) {
    recursive_pup<DpcppPmePencilXY>(dynamic_cast<DpcppPmePencilXY*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_DpcppPmePencilX::virtual_pup(PUP::er &p) {
    recursive_pup<DpcppPmePencilX>(dynamic_cast<DpcppPmePencilX*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_DpcppPmePencilY::virtual_pup(PUP::er &p) {
    recursive_pup<DpcppPmePencilY>(dynamic_cast<DpcppPmePencilY*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_DpcppPmePencilZ::virtual_pup(PUP::er &p) {
    recursive_pup<DpcppPmePencilZ>(dynamic_cast<DpcppPmePencilZ*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
